<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Client Certificate authentication using Azure API Management | Beneath Abstraction</title>
<meta name=keywords content="Azure,Security,API Management,Authentication"><meta name=description content="Introduction
APIs have become so popular that almost all websites and applications rely on APIs to get data from server. Often user impersonation is used to authenticate as well as authorize access to the resource exposed by an API, but there are also use cases where application itself needs data from an API for functioning. Currently the most used authentication mechanism is OAuth, where identity management is performed by a third provider and both the client and resource server trusts this identity provider. While this works well, there is also another way to authenticate when the interaction is purely machine to machine, and works based on  SSL certificates and is called Client Certificate Authentication."><meta name=author content="Me"><link rel=canonical href=https://www.beneathabstraction.com/post/clientcertauthapim/><meta name=google-site-verification content="G-GMEVCEV281"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://www.beneathabstraction.com/images/logo.png><link rel=icon type=image/png sizes=16x16 href=https://www.beneathabstraction.com/images/logo.png><link rel=icon type=image/png sizes=32x32 href=https://www.beneathabstraction.com/images/logo.png><link rel=apple-touch-icon href=https://www.beneathabstraction.com/images/logo.png><link rel=mask-icon href=https://www.beneathabstraction.com/images/logo.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.beneathabstraction.com/post/clientcertauthapim/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript>(function(e,t,n,s,o,i,a){e[n]=e[n]||function(){(e[n].q=e[n].q||[]).push(arguments)},i=t.createElement(s),i.async=1,i.src="https://www.clarity.ms/tag/"+o,a=t.getElementsByTagName(s)[0],a.parentNode.insertBefore(i,a)})(window,document,"clarity","script","oo3areu9yf")</script><meta property="og:title" content="Client Certificate authentication using Azure API Management"><meta property="og:description" content="Introduction
APIs have become so popular that almost all websites and applications rely on APIs to get data from server. Often user impersonation is used to authenticate as well as authorize access to the resource exposed by an API, but there are also use cases where application itself needs data from an API for functioning. Currently the most used authentication mechanism is OAuth, where identity management is performed by a third provider and both the client and resource server trusts this identity provider. While this works well, there is also another way to authenticate when the interaction is purely machine to machine, and works based on  SSL certificates and is called Client Certificate Authentication."><meta property="og:type" content="article"><meta property="og:url" content="https://www.beneathabstraction.com/post/clientcertauthapim/"><meta property="og:image" content="https://www.beneathabstraction.com/images/logo.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-27T20:03:08+11:00"><meta property="article:modified_time" content="2022-02-27T20:03:08+11:00"><meta property="og:site_name" content="Beneath Abstraction"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.beneathabstraction.com/images/logo.png"><meta name=twitter:title content="Client Certificate authentication using Azure API Management"><meta name=twitter:description content="Introduction
APIs have become so popular that almost all websites and applications rely on APIs to get data from server. Often user impersonation is used to authenticate as well as authorize access to the resource exposed by an API, but there are also use cases where application itself needs data from an API for functioning. Currently the most used authentication mechanism is OAuth, where identity management is performed by a third provider and both the client and resource server trusts this identity provider. While this works well, there is also another way to authenticate when the interaction is purely machine to machine, and works based on  SSL certificates and is called Client Certificate Authentication."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.beneathabstraction.com/post/"},{"@type":"ListItem","position":2,"name":"Client Certificate authentication using Azure API Management","item":"https://www.beneathabstraction.com/post/clientcertauthapim/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Client Certificate authentication using Azure API Management","name":"Client Certificate authentication using Azure API Management","description":"Introduction APIs have become so popular that almost all websites and applications rely on APIs to get data from server. Often user impersonation is used to authenticate as well as authorize access to the resource exposed by an API, but there are also use cases where application itself needs data from an API for functioning. Currently the most used authentication mechanism is OAuth, where identity management is performed by a third provider and both the client and resource server trusts this identity provider. While this works well, there is also another way to authenticate when the interaction is purely machine to machine, and works based on SSL certificates and is called Client Certificate Authentication.\n","keywords":["Azure","Security","API Management","Authentication"],"articleBody":"Introduction APIs have become so popular that almost all websites and applications rely on APIs to get data from server. Often user impersonation is used to authenticate as well as authorize access to the resource exposed by an API, but there are also use cases where application itself needs data from an API for functioning. Currently the most used authentication mechanism is OAuth, where identity management is performed by a third provider and both the client and resource server trusts this identity provider. While this works well, there is also another way to authenticate when the interaction is purely machine to machine, and works based on SSL certificates and is called Client Certificate Authentication.\nWhat is? Client certificate authentication is based on the same principle as the SSL certificates that a webserver uses to prove the authenticity to the browsers. In the client certificate scenario the client sends a SSL certificate to server to prove its authenticity. The client gets a SSL certificate signed by a trusted certifying authority (CA) and sends this certificate to the server in its request. The server verifies the certificate based on its list of trusted CAs and then performs further checks to validate the client to which the certificate was issued, to authenticate the caller. Since this method avoids exchange of tokens or secrets and certificates are encrypted using PKI and protected by passphrases this method is more secure compared to token based.\nImplementation To implement a development version of the setup we are going to use the below setup.\nSimple Azure Functions as the backend API. Gitbash to work with openssl to generate self signed certificates and keys for dev environment. Azure API Management to expose function app and perform the client certificate validation. Postman to send requests and verify responses. Azure function app Create a simple function app that accepts a name parameter and returns “Hello ”\nusing System.Net; using Microsoft.AspNetCore.Mvc; using Microsoft.Extensions.Primitives; public static async Task\u003cIActionResult\u003e Run(HttpRequest req, ILogger log) { string name = req.Query[\"name\"]; string responseMessage = string.IsNullOrEmpty(name) ? \"Hello, World.\" : $\"Hello, {name}.\"; return new OkObjectResult(responseMessage); } SSL Certificates For production scenario, the client organization would get a SSL certificate that is signed by a trusted certifying authority. For the demo or development purpose, we can generate an SSL certificate on our computer using openssl utility. This utility comes pre-installed on linux distributions or it can be installed from openssl.org. On windows it is little tricky to install, but if you have gitbash installed, then it has openssl already configured, the below command can be executed on gitbash.\nTo generate self signed ssl certificate, run the below command on gitbash\nopenssl req -newkey rsa:2048 -nodes -keyout domain.key -x509 -days 365 -out domain.crt The above command will ask for a passcode for the key and the organization details and generate the key and a certificate that is valid 365 days. The certificate is signed using the key (your key) hence it is called self signed certificate. For production environment, the api client should be creating a CSR (Certificate Sighing Request) and then get it signed by the certifying authority to get a valid certificate that is accepted by third party.\nThe certificate that is generated in the above step is pem format, to test with Azure API Management, it needs to be of pfx format. This conversion can be done using openssl as below. The command will request for passcode for the key which is the same passcode that was set in the above step. It will also ask for a export passcode, this passcode will be asked every time the certificate is imported, this is for added security to avoid certificate being used a malicious actor.\nopenssl pkcs12 -inkey domain.key -in domain.crt -export -out domain.pfx Azure API Management First step is to Create an API Management instance and enable to receive client certificates in the requests. This can be done by navigating to Deployment + infrastructure \u003e Custom Domain and select the default gate and enabling Negotiate Client Certificates.\nAfter this is done, add the function app to APIM and expose it as an API.\nNow to add policy to validate certificates for authentication. To verify if the certificate submitted by the client is a trusted CA signed certificate we can be use the method context.Request.Certificate.Verify(), also we can verify if the certificate is issued to the client app using context.Request.Certificate.SubjectName.Name != \"expected-subject-name\"\nso to authenticate by validating the certificate signing authority and if the certificate is issues to the expected client application, we can use the below policy\n","wordCount":"1225","inLanguage":"en","image":"https://www.beneathabstraction.com/images/logo.png","datePublished":"2022-02-27T20:03:08+11:00","dateModified":"2022-02-27T20:03:08+11:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.beneathabstraction.com/post/clientcertauthapim/"},"publisher":{"@type":"Organization","name":"Beneath Abstraction","logo":{"@type":"ImageObject","url":"https://www.beneathabstraction.com/images/logo.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.beneathabstraction.com/ accesskey=h title="_ (Alt + H)"><img src=https://www.beneathabstraction.com/images/logo.png alt aria-label=logo height=35>_</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.beneathabstraction.com/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://www.beneathabstraction.com/tags/ title=tags><span>tags</span></a></li><li><a href=https://www.beneathabstraction.com/archives title=archive><span>archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.beneathabstraction.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.beneathabstraction.com/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Client Certificate authentication using Azure API Management</h1><div class=post-meta><span title='2022-02-27 20:03:08 +1100 +1100'>February 27, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1225 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/gopkumr/gopkumr.github.io/tree/main/content/post/clientcertauthapim.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#what-is>What is?</a></li><li><a href=#implementation>Implementation</a><ul><li></li></ul></li><li><a href=#testing>Testing</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>APIs have become so popular that almost all websites and applications rely on APIs to get data from server. Often user impersonation is used to authenticate as well as authorize access to the resource exposed by an API, but there are also use cases where application itself needs data from an API for functioning. Currently the most used authentication mechanism is OAuth, where identity management is performed by a third provider and both the client and resource server trusts this identity provider. While this works well, there is also another way to authenticate when the interaction is purely machine to machine, and works based on SSL certificates and is called Client Certificate Authentication.</p><h2 id=what-is>What is?<a hidden class=anchor aria-hidden=true href=#what-is>#</a></h2><p>Client certificate authentication is based on the same principle as the SSL certificates that a webserver uses to prove the authenticity to the browsers. In the client certificate scenario the client sends a SSL certificate to server to prove its authenticity. The client gets a SSL certificate signed by a trusted certifying authority (CA) and sends this certificate to the server in its request. The server verifies the certificate based on its list of trusted CAs and then performs further checks to validate the client to which the certificate was issued, to authenticate the caller. Since this method avoids exchange of tokens or secrets and certificates are encrypted using PKI and protected by passphrases this method is more secure compared to token based.</p><h2 id=implementation>Implementation<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h2><p>To implement a development version of the setup we are going to use the below setup.</p><blockquote><ul><li>Simple Azure Functions as the backend API.</li><li>Gitbash to work with openssl to generate self signed certificates and keys for dev environment.</li><li>Azure API Management to expose function app and perform the client certificate validation.</li><li>Postman to send requests and verify responses.</li></ul></blockquote><h4 id=azure-function-app>Azure function app<a hidden class=anchor aria-hidden=true href=#azure-function-app>#</a></h4><p>Create a simple function app that accepts a name parameter and returns &ldquo;Hello &rdquo;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c# data-lang=c#><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Net</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>Microsoft.AspNetCore.Mvc</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>Microsoft.Extensions.Primitives</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=kd>async</span> <span class=n>Task</span><span class=p>&lt;</span><span class=n>IActionResult</span><span class=p>&gt;</span> <span class=n>Run</span><span class=p>(</span><span class=n>HttpRequest</span> <span class=n>req</span><span class=p>,</span> <span class=n>ILogger</span> <span class=n>log</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>name</span> <span class=p>=</span> <span class=n>req</span><span class=p>.</span><span class=n>Query</span><span class=p>[</span><span class=s>&#34;name&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>string</span> <span class=n>responseMessage</span> <span class=p>=</span> <span class=kt>string</span><span class=p>.</span><span class=n>IsNullOrEmpty</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>?</span> <span class=s>&#34;Hello, World.&#34;</span>
</span></span><span class=line><span class=cl>                <span class=p>:</span> <span class=s>$&#34;Hello, {name}.&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>OkObjectResult</span><span class=p>(</span><span class=n>responseMessage</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=ssl-certificates>SSL Certificates<a hidden class=anchor aria-hidden=true href=#ssl-certificates>#</a></h4><p>For production scenario, the client organization would get a SSL certificate that is signed by a trusted certifying authority. For the demo or development purpose, we can generate an SSL certificate on our computer using openssl utility. This utility comes pre-installed on linux distributions or it can be installed from <a href=https://www.openssl.org/>openssl.org</a>. On windows it is little tricky to install, but if you have gitbash installed, then it has openssl already configured, the below command can be executed on gitbash.</p><p>To generate self signed ssl certificate, run the below command on gitbash</p><pre tabindex=0><code>openssl req -newkey rsa:2048 -nodes -keyout domain.key -x509 -days 365 -out domain.crt
</code></pre><p>The above command will ask for a passcode for the key and the organization details and generate the key and a certificate that is valid 365 days. The certificate is signed using the key (your key) hence it is called self signed certificate. For production environment, the api client should be creating a CSR (Certificate Sighing Request) and then get it signed by the certifying authority to get a valid certificate that is accepted by third party.</p><p>The certificate that is generated in the above step is pem format, to test with Azure API Management, it needs to be of pfx format. This conversion can be done using openssl as below. The command will request for passcode for the key which is the same passcode that was set in the above step. It will also ask for a export passcode, this passcode will be asked every time the certificate is imported, this is for added security to avoid certificate being used a malicious actor.</p><pre tabindex=0><code>openssl pkcs12 -inkey domain.key -in domain.crt -export -out domain.pfx
</code></pre><h4 id=azure-api-management>Azure API Management<a hidden class=anchor aria-hidden=true href=#azure-api-management>#</a></h4><p>First step is to Create an API Management instance and enable to receive client certificates in the requests. This can be done by navigating to Deployment + infrastructure > Custom Domain and select the default gate and enabling Negotiate Client Certificates.</p><p><img loading=lazy src=/blogimages/apimcert.png alt="Client Certificate">
<img loading=lazy src=/blogimages/CertEnable.png alt="Enable Client Certificate"></p><p>After this is done, add the function app to APIM and expose it as an API.</p><p>Now to add policy to validate certificates for authentication.
To verify if the certificate submitted by the client is a trusted CA signed certificate we can be use the method <code>context.Request.Certificate.Verify()</code>, also we can verify if the certificate is issued to the client app using <code>context.Request.Certificate.SubjectName.Name != "expected-subject-name"</code></p><p>so to authenticate by validating the certificate signing authority and if the certificate is issues to the expected client application, we can use the below policy</p><pre tabindex=0><code>&lt;choose&gt;
    &lt;when condition=&#34;@(context.Request.Certificate == null || !context.Request.Certificate.Verify() || context.Request.Certificate.SubjectName.Name != &#34;expected-subject-name&#34;)&#34; &gt;
        &lt;return-response&gt;
            &lt;set-status code=&#34;403&#34; reason=&#34;Invalid client certificate&#34; /&gt;
        &lt;/return-response&gt;
    &lt;/when&gt;
&lt;/choose&gt;
</code></pre><p>If there are multiple client applications accessing the API, instead of validating the subject name for each, there is an option to upload the client&rsquo;s&rsquo; certificate to API Management directly or via a keyvault and validate incoming certificates against this list of trusted certificates. You can upload the certificates by navigating to Security > Certificates and (Certificates tab) add. The CA certificates tab in this screen is to upload the certificate chain of root and intermediate CA certificates in the event where the signing authority is not in the Azure trusted CA list.</p><p><img loading=lazy src=/blogimages/certupload.png alt="Client Certificate">
once we have the client certificates uploaded we can update the policy to validate is against the certificates from the uploaded trusted list of certificate</p><pre tabindex=0><code>&lt;choose&gt;
    &lt;when condition=&#34;@(context.Request.Certificate == null || !context.Request.Certificate.Verify()  || !context.Deployment.Certificates.Any(c =&gt; c.Value.SubjectName.Name == context.Request.Certificate.SubjectName.Name))&#34; &gt;
        &lt;return-response&gt;
            &lt;set-status code=&#34;403&#34; reason=&#34;Invalid client certificate&#34; /&gt;
        &lt;/return-response&gt;
    &lt;/when&gt;
&lt;/choose&gt;
</code></pre><p>or compare against certificate thumbprint</p><pre tabindex=0><code>&lt;choose&gt;
    &lt;when condition=&#34;@(context.Request.Certificate == null || !context.Request.Certificate.Verify()  || !context.Deployment.Certificates.Any(c =&gt; c.Value.Thumbprint == context.Request.Certificate.Thumbprint))&#34; &gt;
        &lt;return-response&gt;
            &lt;set-status code=&#34;403&#34; reason=&#34;Invalid client certificate&#34; /&gt;
        &lt;/return-response&gt;
    &lt;/when&gt;
&lt;/choose&gt;
</code></pre><p>Since the certificate that we are using for testing is a self signed certificate, the call to <code>context.Request.Certificate.Verify()</code> will fail due to missing trusted CA sign. So we remove this check for testing purpose only.
so the final policy looks like this</p><pre tabindex=0><code>&lt;choose&gt;
    &lt;when condition=&#34;@(context.Request.Certificate == null ||  !context.Deployment.Certificates.Any(c =&gt; c.Value.Thumbprint == context.Request.Certificate.Thumbprint))&#34; &gt;
        &lt;return-response&gt;
            &lt;set-status code=&#34;403&#34; reason=&#34;Invalid client certificate&#34; /&gt;
        &lt;/return-response&gt;
    &lt;/when&gt;
&lt;/choose&gt;
</code></pre><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><p>To test the API, we can create a dotnet client and add the certificate to the request and send to the APIM endpoint or to make testing quick, we can use postman to trigger the APIM endpoint.</p><p>If you try calling the APIM endpoint without a certificate, you get back a Http 403 error response, saying Invalid client certificate</p><p>So you need to add the certificate to postman, which will be sent as part of the request.</p><p>Navigate to <em>Settings > Certificates</em> tab and click on Add Certificate.</p><p><img loading=lazy src=/blogimages/postmancert.png alt="Client Certificate"><br>In the Host field, enter the domain of the request URL (<em>APIM Host Name e.g. {APIMName}.azure-api.net</em>) for which the certificate has to be sent. You can choose the pfx certificate file and the key file from the earlier setup. Also the passcode the one that was setup while creating the key file.</p><p>If you now try calling the APIM endpoint, you will receive the response message with a Http 200 code.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This is a quick, but secure way of establishing trust between two machines, without the need for extra http calls to generate or validate tokens. Also, when the certificate expires, the client needs ti just provide the server with the renewed certificate to upload to the store.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.beneathabstraction.com/tags/azure/>Azure</a></li><li><a href=https://www.beneathabstraction.com/tags/security/>Security</a></li><li><a href=https://www.beneathabstraction.com/tags/api-management/>API Management</a></li><li><a href=https://www.beneathabstraction.com/tags/authentication/>Authentication</a></li></ul><nav class=paginav><a class=prev href=https://www.beneathabstraction.com/post/azurestoragesftp/><span class=title>« Prev</span><br><span>Exposing Azure Storage container via SFTP</span>
</a><a class=next href=https://www.beneathabstraction.com/post/functionappclone/><span class=title>Next »</span><br><span>Cloning a Azure Function App</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Client Certificate authentication using Azure API Management on x" href="https://x.com/intent/tweet/?text=Client%20Certificate%20authentication%20using%20Azure%20API%20Management&amp;url=https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f&amp;hashtags=Azure%2cSecurity%2cAPIManagement%2cAuthentication"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Client Certificate authentication using Azure API Management on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f&amp;title=Client%20Certificate%20authentication%20using%20Azure%20API%20Management&amp;summary=Client%20Certificate%20authentication%20using%20Azure%20API%20Management&amp;source=https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Client Certificate authentication using Azure API Management on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f&title=Client%20Certificate%20authentication%20using%20Azure%20API%20Management"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Client Certificate authentication using Azure API Management on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Client Certificate authentication using Azure API Management on whatsapp" href="https://api.whatsapp.com/send?text=Client%20Certificate%20authentication%20using%20Azure%20API%20Management%20-%20https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Client Certificate authentication using Azure API Management on telegram" href="https://telegram.me/share/url?text=Client%20Certificate%20authentication%20using%20Azure%20API%20Management&amp;url=https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Client Certificate authentication using Azure API Management on ycombinator" href="https://news.ycombinator.com/submitlink?t=Client%20Certificate%20authentication%20using%20Azure%20API%20Management&u=https%3a%2f%2fwww.beneathabstraction.com%2fpost%2fclientcertauthapim%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><script src=https://giscus.app/client.js data-repo=gopkumr/gopkumr.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzNDU1NjQ0NTM=" data-category=General data-category-id=DIC_kwDOFJjlJc4Cgwlh data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.beneathabstraction.com/>Beneath Abstraction</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>